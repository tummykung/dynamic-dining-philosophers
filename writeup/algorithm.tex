\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, enumerate, mathpazo, mathrsfs, fancyhdr, mathrsfs, graphicx, framed}
\usepackage[tmargin = 1in, lmargin = 1.1in, rmargin = 1in, bmargin = 1in]{geometry}
%%%%%%%%%%%%%%%%%%%%%%% IMPORTANT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                             %
%       In the end, we should submit only algorithms.pdf      %
%                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{courier}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=erlang,            % choose the language of the code
basicstyle=\footnotesize,   % the size of the fonts that are used for the code
numbers=left,               % where to put the line-numbers
numberstyle=\footnotesize,  % the size of the fonts that are used for the line-numbers
stepnumber=1,               % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,              % how far the line-numbers are from the code
backgroundcolor=\color{white}, % choose the background color. You must add \usepackage{color}
showspaces=false,           % show spaces adding particular underscores
showstringspaces=false,     % underline spaces within strings
showtabs=false,             % show tabs within strings adding particular underscores
frame=single,               % adds a frame around the code
tabsize=2,                  % sets default tabsize to 2 spaces
captionpos=b,               % sets the caption-position to bottom
breaklines=true,            % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)} % if you want to add a comment within your code
}

%%% MACROS
\newcommand{\pic}[2]{\begin{center}\includegraphics[scale=#1]{#2}\end{center}}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\comp}[1]{\overline{#1}}

%%% MATH OPERATORS
\DeclareMathOperator{\var}{Var}

%%% PARAMETERS
\setlength{\headheight}{15.2pt}
\renewcommand{\tabcolsep}{1cm}

%%% ENUMERATE
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\labelenumi}{(\theenumi)}
\renewcommand{\theenumii}{\roman{enumii}}
\renewcommand{\labelenumii}{\theenumii.}

%%% PROBLEM ENVIRONMENT
\newenvironment{problem}[1]{
\medskip \hrule \medskip
\noindent {\bf Problem #1.}
}{
\medskip \hrule \medskip
}

%%% SOLUTION ENVIRONMENT
\newenvironment{solution}{\noindent{\bf Solution.} }{

\hfill$\square$}

\begin{document}
\pagestyle{fancy}

\lhead{Tum C., Patrick L., Cory P.
}
\chead{\bf{Math 182E}}
\rhead{March 13, 2014}

\begin{center} \Large Algorithms: The Dynamic Dining Philosophers \end{center}

\section{Introduction}


\subsection{Problem Statement}
We need to develop and implement a protocol that allows nodes to join or leave a running dining philosophers network at runtime in an orderly fashion while maintaining an acyclic priority graph, ensuring safety, and preventing deadlock.



\section{Allowed Assumptions}

\begin{description}
\item[External controllers (a1)]
If a philosopher $p$ informs an external controller that it is \emph{eating}, the external controller will direct $p$ to become either \emph{thinking} or \emph{leaving} within a bounded time.
External controllers will not send duplicate or invalid control signals.
\end{description}

\section{Solution}
\subsection{Overview}
Our solution is based on a hiegenic solution discussed in class. To avoid deadlocks, we maintain a priority graphs, in which the person with a higher priority gets to eat first when two of adjacent philosophers are hungry. We use a fork mechanism to represent the priority graph in a distributed fashion. There is exactly one fork per each edge between two nodes, where nodes represent philosophers. Each fork can be either \texttt{dirty} or \texttt{clean}. A clean fork implies that the person holding it has a higher priority than the person at the other end of an edge. Conversely, a dirty fork implies that the person holding it has a lower priority. In this assignment, we extend this algorithm to allow philosphers to join and leave the table, while still maintain the acyclic priority graph, ensuring safey, and preventing deadlock.


\section{Algorithms}

\section{Proof of Correctness}

\section{Proof of Progress}
\underline{\large{Progress.}}

$p.joining$ $\leadsto$ $p.thinking$

\indent After philosopher $p$ has started up, it has given itself the $joining$ state. Assuming that the neighbors in which $p$ knows about are running correctly and the network runs as expected, all other philosophers are bound to hear $p$'s request to join eventually and thus $p$ is guaranteed to be given the state $thinking$.

$p.hungry$ $\leadsto$ $p.eating$

\indent When $hungry$, a philosopher $p$ must be passed the forks once all neighbor philosophers are not eating

$p.leaving$ $\leadsto$ $p.gone$

\indent


\underline{\large{Safety.}}

In order to show that the algorithm satisfies the Safety requirement, we must show that the relevant stages satisfy the Safety properties:

{\bfseries initially} {\it p.joining}

\indent $p$ is given the state of $joining$ in which the philosopher $p$ is requesting to join the group and cannot possibly gain any other state until granted acceptance.

{\it p.joining} {\bfseries next} {\it (p.joining $\vee$ p.thinking)}

\indent This requirement is satisfied because $p$ can be constantly trying to join the party but may be waiting infinitely or he/she can be granted the state of thinking (which is the only initial state in the party).

{\it p.thinking} {\bfseries next} {\it (p.thinking $\vee$ p.hungry $\vee$ p.leaving)}

\indent When thinking, the philosopher $p$ can continue thinking, the external controller can issue the order to become hungry, or the controller may tell the philosopher to leave. No other "state" transitions are available to the philosopher at the $thinking$ state. 

{\it p.hungry} {\bfseries next} {\it (p.hungry $\vee$ p.eating $\vee$ p.leaving)}

\indent If a philosopher $p$ is told by the external controller to become hungry, then it may be told to leave, it may become eating due to its hungry nature, or $p$ may remain hungry (which would likely imply a failure in the system).

{\it p.eating} {\bfseries next} {\it (p.eating $\vee$ p.thinking $\vee$ p.leaving)}

\indent

{\it p.leaving} {\bfseries next} {\it (p.leaving $\vee$ p.gone)}

\indent

{\it p.gone} {\bfseries next} {\it (p.gone)}

\indent

{\it p.eating} $\rightarrow \langle \forall q | q \in p.neighbors \rhd \not q.eating \rangle$
(when a philosopher $p$ is $eating$, none of its neighbors is $eating$)

\indent 

{\it (p.thinking $\vee$ p.hungry $\vee$ p.eating)} $\langle \rightarrow \forall q | q \in p.neighbors \rhd p \in q.neighbors \rangle$
(when a philosopher $p$ is $thinking$, $hungry$, or $eating$, each of $p$'s neighbors knows that $p$ is one of its neighbors)

\indent

{\it p.gone} $\rightarrow \langle \forall q  \rhd \not\in q.neighbors \rangle$
(when a philosopher $p$ is $gone$, it is not in any other philosopher?s set of neighbors)

\indent

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\section{Appendix: Relevant Code}

\begin{lstlisting}
infinite_loop(Ref, Nodel, Neighbors) ->
    spelling, Node} ! {self(), Ref, become_hungry},
    % {spelling, Node} ! {self(), Ref, stop_eating},
    % {spelling, Node} ! {self(), Ref, leave},
    receive
        %{Ref, eating} ->          
        %print("~p is eating.~n", [Ref]);
        {Ref, gone} ->
        print("~p is gone.~n", [Ref]);
        Reply ->
        print("Got unexpected message: ~p~n", [Reply])
        after ?TIMEOUT -> print("Timed out waiting for reply!")
    end,
    infinite_loop(Ref, Nodel, Neighbors)
end.
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, joining, Node, ForksNeighborsList)->
        print("joining"),
        %philosophize(Ref, thinking, Node, Neighbors);
    requestJoin(Ref, Node, ForksNeighborsList),
    philosophize(Ref, thinking, ForksNeighborsList).
    
%requests each neighbor to join the network, one at a time,
%when joining there shouldn't be any other requests for forks or leaving going on
requestJoin(_,_,[])-> ok;
requestJoin(Ref, Node, ForksNeighborsList)->
    try
        io:format("Process ~p at node ~p sending request to ~n~s",
            [self(), Node, hd(Neighbors)]),
        io:format("After~n"),
        {list_to_atom(hd(Neighbors)), Node} ! {self(), Ref, requestJoin},
        receive
            {Ref, ok} ->
                io:format("Got reply (from ~p): ok!",
                          [Ref);
            Reply ->
                io:format("Got unexpected message: ~p~n", [Reply])
        after ?TIMEOUT -> io:format("Timed out waiting for reply!")
        end,
        requestJoin(Ref, Node, tl(Neighbors))
    catch
        _:_ -> io:format("Error getting joining permission.~n")
    end.
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, thinking, Node, ForksNeighborsList)->
        receive
           {self(), NewRef, leave} ->
           print("leaving"),
           philosophize(NewRef, leaving, ForksNeighborsList);
           {self(), NewRef, become_hungry} ->
                   print("becoming hungry"),
                   philosophize(NewRef, hungry, ForksNeighborsList)
	after ?TIMEOUT -> print("Timed out waiting for reply!")
        end;
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, hungry, Node, ForksNeighborsList)->
        receive
            {self(), NewRef, leave} ->
                    print("leaving"),
                    philosophize(NewRef, leaving, Node, ForksNeighborsList);
        %   {self(), NewRef, Fork} ->  AND/OR CHECK IF ALL NEIGHBORS ARE NOT EATING?
                %print("got fork"),
                % check if has all forks
                % continue with philosophize(NewRef, 

        %end;

        % want to receive all forks and then start eating
        {controller, Node} ! {NewRef, eating},
        print("eating"),
        philosophize(Ref, eating, Node, ForksNeighborsList)
        end;
\end{lstlisting}
\begin{lstlisting}
philosophize(Ref, eating, Node, ForksNeighborsList)->
        receive
           {self(), NewRef, stop_eating} ->
                % handle forks and hygenity if doing that
                print("stopping eating"),
                philosophize(NewRef, thinking, Node, ForksNeighborsList);
           {self(), NewRef, leave} ->
                print("stopping eating and leaving"),
                %get rid of forks
                philosophize(NewRef, leaving, Node, ForksNeighborsList)
        after ?TIMEOUT -> print("Timed out waiting for reply!")
        end;
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, leaving, Node, ForksNeighborsList)->
        %need to gather forks and then leave with them
        {controller, Node} ! {Ref, gone}.
\end{lstlisting}


\end{document}