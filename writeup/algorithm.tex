\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, enumerate, mathpazo, mathrsfs, fancyhdr, mathrsfs, graphicx, framed, float}
\usepackage[tmargin = 1in, lmargin = 1.1in, rmargin = 1in, bmargin = 1in]{geometry}
%%%%%%%%%%%%%%%%%%%%%%% IMPORTANT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                             %
%       In the end, we should submit only algorithms.pdf      %
%                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{courier}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=erlang,            % choose the language of the code
basicstyle=\footnotesize,   % the size of the fonts that are used for the code
numbers=left,               % where to put the line-numbers
numberstyle=\footnotesize,  % the size of the fonts that are used for the line-numbers
stepnumber=1,               % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,              % how far the line-numbers are from the code
backgroundcolor=\color{white}, % choose the background color. You must add \usepackage{color}
showspaces=false,           % show spaces adding particular underscores
showstringspaces=false,     % underline spaces within strings
showtabs=false,             % show tabs within strings adding particular underscores
frame=single,               % adds a frame around the code
tabsize=2,                  % sets default tabsize to 2 spaces
captionpos=b,               % sets the caption-position to bottom
breaklines=true,            % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)} % if you want to add a comment within your code
}

%%% MACROS
\newcommand{\pic}[2]{\begin{center}\includegraphics[scale=#1]{#2}\end{center}}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\comp}[1]{\overline{#1}}

%%% MATH OPERATORS
\DeclareMathOperator{\var}{Var}

%%% PARAMETERS
\setlength{\headheight}{15.2pt}
\renewcommand{\tabcolsep}{1cm}

%%% ENUMERATE
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\labelenumi}{(\theenumi)}
\renewcommand{\theenumii}{\roman{enumii}}
\renewcommand{\labelenumii}{\theenumii.}

\title{The Algorithm for the Dynamic Dining Philosophers Problem}

%%% PROBLEM ENVIRONMENT
\newenvironment{problem}[1]{
\medskip \hrule \medskip
\noindent {\bf Problem #1.}
}{
\medskip \hrule \medskip
}

%%% SOLUTION ENVIRONMENT
\newenvironment{solution}{\noindent{\bf Solution.} }{

\hfill$\square$}

\begin{document}
\pagestyle{fancy}

\lhead{Tum C., Patrick L., Cory P.
}
\chead{\bf{CSCI 182E} Distributed Systems}
\rhead{March 13, 2014}

\vspace*{0.1in}
\begin{center} \Large The Algorithm for the Dynamic Dining Philosophers Problem \end{center}

\section{The Dynamic Dining Philosophers}
\begin{problem}{Statement}
We need to develop and implement a protocol that allows nodes to join or leave a running dining philosophers network at runtime in an orderly fashion while maintaining an acyclic priority graph, ensuring safety, and preventing deadlock.
\end{problem}

Our solution is based on a hiegenic solution discussed in class. To avoid deadlocks, we maintain a priority graphs, in which the person with a higher priority gets to eat first when two of adjacent philosophers are hungry. We use a fork mechanism to represent the priority graph in a distributed fashion. There is exactly one fork per each edge between two nodes, where nodes represent philosophers. Each fork can be either \texttt{dirty} or \texttt{clean}. A \texttt{clean} fork implies that the person holding it has a higher priority than the person at the other end of an edge. Conversely, a \texttt{dirty} fork implies that the person holding it has a lower priority. In this assignment, we extend this algorithm to allow philosphers to join and leave the table, while still maintain the acyclic priority graph, ensuring safey, and preventing deadlock.


\section{The Algorithm}
\subsection{A set of states}
There are 6 states:
\begin{enumerate}
\item \textit{joining}
\item \textit{thinking}
\item \textit{hungry}
\item \textit{eating}
\item \textit{leaving}
\item \textit{gone}
\end{enumerate}


\subsection{Information Stored by Each Process}
In the Erlang syntax, the $\texttt{philosophize}$ function's header represents
the information stored by each process:
\begin{lstlisting}
philosophize(<state>, Node, Neighbors, ForksList)
\end{lstlisting}
In other words, a process $p$ contains the following information:
\begin{enumerate}
\item $p.state$ ($\langle\texttt{state}\rangle$): one of the six states outlined above.
\item $p.node$ its process node ($\texttt{Node}$), represented as a lowercase ASCII string with a machine name, separated by an @ symbol. (For example, \texttt{p1@ash}) We can always find out our nodename with node(), so it is not passed around.
\item $p.neighbors$ ($\texttt{Neighbors}$): a list of its neighboring processes $[n_1, n_2, \ldots, n_k]$.
\item $p.fork\_states$ ($\texttt{ForkList}$): a list $[f_{p, n_1}, f_{p, n_2}, f_{p, n_3}, \ldots, f_{p, n_k}]$ of fork states for each its neighbors, in the same order as the neighboring list. The fork state can be either 0 or 1, where 1 means the fork belongs to $p$, where as 0 means the fork belongs to its corresponding neigbor. The forks are also either CLEAN or DIRTY to establish the priority. For example, if $p.neighbors = [n_1, n_2, n_3]$ and $p.fork\_states = [[0, _], [1, CLEAN], [0, _]],$ then the fork $f_{p, n_1}$ belongs to $p$; $f_{p, n_2}$ belongs to $n_2$;
and $f_{p, n_3}$ belongs to $n_3$.
\end{enumerate}

\subsection{Message Types in the System}
We categorize messages by its sender and its receiver:
\subsubsection{From Philosophers to Philosophers}
\begin{enumerate}
\item a fork $f_{i,j}$: exactly one fork per one pair of neighboring processes $i$ and $j$. A fork can be dirty (the process holding it has lower prioirty) or clean (the process holding it has higher prioirty).
\item a fork request. The sender philosopher should only send this when it is in the $hungry$ state and it does not hold a fork.
\item a joining request. The sender philosopher, who should be in the joining state, once assigned by the external controller who to join, sends a joining request to each of its intended neighbors.
\item a joining message acknowledgement.
\item a leaving notification.
\item a leaving message acknowledgement.
\end{enumerate}

\subsubsection{From External Controllers to Philosophers}
\begin{enumerate}
\item a \texttt{become\_hungry} message. The philosopher should only receive this message while \textit{thinking}; when it does, it transitions to \textit{hungry}.
\item a \texttt{stop\_eating} message. The philosopher should only receive this message while \textit{eating}; when it does, it transitions to \textit{thinking}. Just before transitioning to thinking, it will immediately handle any previous requests for forks.
\item a \texttt{leave} message. The philosopher can receive this message in any state other than \textit{joining}; when it does, it should ask for acknowledgment from all its neighbors that he is leaving, then immediately leave the network.
\end{enumerate}

\subsubsection{From Philosophers to External Controllers}
\begin{enumerate}
\item an \texttt{eating} message. The philosopher should send this message, when it becomes \textit{eating}, to the controller that trigger its transition to \textit{hungry} (through the \texttt{become\_hungry} message).
\item a \textit{gone} message. When it becomes \textit{gone}, the philosopher should send this message to the controller that sent it the \texttt{leave} message that triggerred its departure.
\end{enumerate}

\subsection{Initial Distributions of Forks}
\begin{enumerate}
\item All forks are dirty.
\item Initially, the first philosopher has no fork. When another philosopher requests to be his neighbor, he sends a request. The receiving philosopher will create a dirty fork. This prevents cycles since there is a possibility that if the fork was clean, he would never give it up.
\end{enumerate}

\subsection{Actions before Transitions}
\begin{figure}[H]
\pic{0.6}{diagram}
\label{fig:diagram}
\caption{A diagram showing possible state transitions.}
\end{figure}

We will describe what would happen when a philosopher receives a fork.


\begin{description}
\item[(1) $p.joining$ $\to$ $p.thinking$:] sends a joining request to all of its neighbors. Once it receives all joining message acknowledgments from all its neighbors, transition to the \textit{thinking} state.

\item[(2) $p.thinking$ $\to$ $p.hungry$:]
The philosopher checks to see if it holds all forks. If so, performs the transition. If not, it waits until it receives another fork and checks if he has them all again, until he actually has them all and transitions to eating.

\item[(3) $p.hungry$ $\to$ $p.eating$:] 
When transitioning from $p.hungry$ to $p.eating$, the philosopher makes all forks dirty, thereby making its priority lowest among all its neighbors.

% When $hungry$, a philosopher $p$ must be passed the forks once all neighbor philosophers are not eating

\item[(4) $p.eating$ $\to$ $p.thinking$:]
The phisolopher sends any forks for which it received requests while eating.

\item[(5) $(p.thinking \vee p.hungry \vee p.eating)$ $\to$ $p.leaving$:]
The philosopher sends leaving notifications to all of its neighbors.
Once received leaving notification acknowledgements from all of its neighbors,
it can immediately go to the $leaving$ state.

\item[(6) $p.leaving$ $\to$ $p.gone$:]
Eventually
\end{description}
\subsection{Incoming Request Messages}
When a fork message is received, the philosopher marks the fork as clean.

\begin{description}
\item[During $p.hungry$] if the philosopher now holds all its forks, it transitions to $eating$ state.
\end{description}
\subsection{Incoming Fork Messages}
TODO: Add more details


\subsection{How a new philosopher informs its neighbors that it has joined the network}
Sends joining requests to all of their neighbors

\subsection{How a new philosopher knows that its neighbors are aware that it has joined the network}
Waits for joining request acknowledgement messages from all of its neighbors.
\subsection{How a philosopher informs its neighbors that it is leaving the network}
Sends leaving notifications to all of their neighbors

\subsection{How a philosopher knows that its neighbors are aware that it is leaving the network}
Waits for leaving notification acknowledgements from all of its neighbors.

\section{Allowed Assumptions}

\subsection{External Controllers}
\begin{enumerate}[E1]
\item If a philosopher $p$ informs an external controller that it is \emph{eating}, the external controller will direct $p$ to become either \emph{thinking} or \emph{leaving} within a bounded time.

\item External controllers will not send duplicate or invalid control signals.

\item \label{Assump:E_guarantees_nodes_entering_network} If a process $p_1$ receives a joining request from another process $p_2$, external controllers will not send signals to ask $p_1$ to leave until $p_2$ successfully joins the network.
\end{enumerate}

\subsection{Misc.}
\begin{enumerate}[E1]
\setcounter{enumi}{3}
\item \label{Assump:message_never_lost} Messages are never lost; sufficient time is allowed for a philosopher to bootstrap itself before other philosophers send it messages.
\end{enumerate}


\section{Proof of Correctness}


\subsection{Proof of Acyclic Priority Graph Invariance}
The prioirity graph changes only in three possible cases.
\begin{description}
\item[Case 1: A new process joins the network.] In this case, the new process has the lowest priority. Thus, all its neighbors will have arrow point to it. Thus, if there were a cycle, such cycle could not possibly pass this new process. Since the original graph was acyclic, there could not be cycles elsewhere as well. Thus, the resulting priority graph is still acyclic.
\item[Case 2: A process leaves the network.] A new priority graph is a subgraph of the original graph, and so the new graph cannot have cycles. If it were to have any cycles, these cycles would have presented in the original graph as well, which is not the case. Thus, the resulting priority network is acyclic.
\item[Case 3: A process eats.] In this case, based on our hiegenic algorithm, such process will then have the lowest priority among all its neighbors. Thus, all the arrow points to it. If there were a cycle, such cycle could not possibly pass this process. Since the original graph was acyclic, there could not be cycles elsewhere as well. Thus, the resulting priority graph is still acyclic.
\end{description}

\subsection{Proof of Safety Properties}

\begin{enumerate}[S1]
\item {\bfseries initially} {\it p.joining}

$p$ is given the state of $joining$ in which the philosopher $p$ is requesting to join the group and cannot possibly gain any other state until granted acceptance.

\item {\it p.joining} {\bfseries next} {\it (p.joining $\vee$ p.thinking)}

This requirement is satisfied because $p$ can be constantly trying to join the party but may be waiting infinitely or it can be granted the state of thinking (which is the only initial state in the party).

\item {\it p.thinking} {\bfseries next} {\it (p.thinking $\vee$ p.hungry $\vee$ p.leaving)}

When thinking, the philosopher $p$ can continue thinking, the external controller can issue the order to become hungry, or the controller may tell the philosopher to leave. No other "state" transitions are available to the philosopher at the $thinking$ state. 

\item {\it p.hungry} {\bfseries next} {\it (p.hungry $\vee$ p.eating $\vee$ p.leaving)}

If a philosopher $p$ is told by the external controller to become hungry, then it may be told to leave, it may become eating due to its hungry nature, or $p$ may remain hungry (which would likely imply a failure in the system).

\item {\it p.eating} {\bfseries next} {\it (p.eating $\vee$ p.thinking $\vee$ p.leaving)}

If a philosopher $p$ is $eating$, then only three cases are possible to the philosopher. First, nothing may happen and the philosopher will continue $eating$. Second, the external controller can tell the philosopher to stop $eating$, in which $p$ would become $thinking$. The external controller can also tell the philosopher to stop $eating$. No other transitions are available at this stage.


\item {\it p.leaving} {\bfseries next} {\it (p.leaving $\vee$ p.gone)}

When a philosopher $p$ has been told to leave by the external controller, it is destined to leave thus may continue its cleanup and remain in the $leaving$ stage or the philosopher could complete the $leaving$ state and leave, successfully terminating and entering the $gone$ state.

\item {\it p.gone} {\bfseries next} {\it (p.gone)}

When a philosopher $p$ is $gone$, the philosopher may not join again (implying it may not reach anymore states) and thus is in the fixed state of $gone$.

\item {\it p.eating} $\Rightarrow \langle \forall q | q \in p.neighbors \rhd \neg q.eating \rangle$
(when a philosopher $p$ is $eating$, none of its neighbors is $eating$)

When a philosopher $p$ is $eating$, then it holds all of its forks that it shares with its neighbors and since a philosopher needs all of the forks it shares with its neighbors, that philosopher with the forks will be the only one eating.


\item {\it (p.thinking $\vee$ p.hungry $\vee$ p.eating)} $\Rightarrow \langle \forall q | q \in p.neighbors \rhd p \in q.neighbors \rangle$
(when a philosopher $p$ is $thinking$, $hungry$, or $eating$, each of $p$'s neighbors knows that $p$ is one of its neighbors)

After joining, a philosopher knows its neighbors and in each state $thinking$, $hungry$, or $eating$, the neighbors list is updated if a neighbor leaves. Thus, each state has a real-time copy of the neighboring philosophers.


\item {\it p.gone} $\Rightarrow \langle \forall q  \rhd \not\in q.neighbors \rangle$
(when a philosopher $p$ is $gone$, it is not in any other philosopher?s set of neighbors)

\end{enumerate}



\section{Proof of Progress Properties}
\begin{enumerate}[PG1]
\item
$p.joining$ $\leadsto^*$ $p.thinking$ ($^*$ if its neighbors remain in the network long enough) 

\indent After philosopher $p$ has started up, it has given itself the $joining$ state. Assuming that the neighbors in which $p$ knows about are running correctly and the network runs as expected and Assumption E\ref{Assump:E_guarantees_nodes_entering_network}, all other philosophers are bound to hear $p$'s request to join eventually and thus $p$ is guaranteed to be given the state $thinking$.

\item  $p.hungry$ $\leadsto$ $p.eating$

\indent When $hungry$, a philosopher $p$ must be passed the forks once all neighbor philosophers are not eating. TODO [Articulate this...but this is the idea]: Based on the acyclic graph property and our algorithm to make just-finished-eating processes have the lowest priority among their neighbors, we guarantee that the a hungry philosopher will eventually eat.

\item 
$p.leaving$ $\leadsto$ $p.gone$
\end{enumerate}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\section{Appendix: Relevant Code}
\begin{lstlisting}
%% CSCI182E - Distributed Systems
%% Harvey Mudd College
%% Dynamic Dining Philosophers
%% @author Tum Chaturapruek, Patrick Lu, Cory Pruce
%% @doc Think, hungry, and eat.
-module(philosopher).

%% ====================================================================
%%                             Public API
%% ====================================================================
-export([main/1]).

%% ====================================================================
%%                             Constants
%% ====================================================================

%% ====================================================================
%%                            Main Function
%% ====================================================================
% The main/1 function.
main(Params) ->
    % try 
        % The first parameter is destination node name
        %  It is a lowercase ASCII string with no periods or @ signs in it.
        NodeName = hd(Params),

        % 0 or more additional parameters, each of which is the Erlang node
        % name of a neighbor of the philosopher.
        NeighborsList = tl(Params),
        Neighbors = lists:map(fun(Node) -> list_to_atom(Node) end, 
          NeighborsList), 
        %% IMPORTANT: Start the empd daemon!
        os:cmd("epmd -daemon"),

        % format microseconds of timestamp to get an 
        % effectively-unique node name
        net_kernel:start([list_to_atom(NodeName), shortnames]),

        register(philosopher, self()),

        %joining
        philosophize(joining, Neighbors, dict:new()),

    halt().


% This is a helper function to that sends forks to all
% processes in a list.
sendForks([], ForksList) -> ForksList;
sendForks(Requests, ForksList) ->
    print("Sending the fork to ~p~n", [hd(Requests)]),
    ForkList = dict:erase(hd(Requests), ForksList),
    NewForkList = dict:append(hd(Requests), {0, "SPAGHETTI"}, ForkList),
    {philosopher, hd(Requests)} ! {node(), fork},
    sendForks(tl(Requests), NewForkList).

% Check to see if a process has all the forks
% it needs to eat
haveAllForks([],_) -> true;
haveAllForks(Neighbors, ForksList) ->
        case (dict:find(hd(Neighbors), ForksList)) of
            %Request the fork
            {ok, [{0,_}]} -> print("Don't have all forks~n"),
                          false;
            {ok, [{1,_}]} -> haveAllForks(tl(Neighbors), ForksList)
        end.

% Constantly query neighbor philosophers to make sure that they are still
% there. If one is gone, delete fork to that philosopher and remove from 
% neighbors list, sufficiently removing the edge. Otherwise, keep
% philosophizing. 

check_neighbors([], _)-> ok;
check_neighbors([X|XS], ParentPid) ->
    spawn(fun() ->  monitor_neighbor(X, ParentPid) end),
    check_neighbors(XS, ParentPid).

monitor_neighbor(Philosopher, ParentPid) ->
    erlang:monitor(process,{philosopher, Philosopher}), %{RegName, Node}
       receive
        {'DOWN', _Ref, process, _Pid,  normal}  ->
            ParentPid ! {self(), check, Philosopher};
        {'DOWN', _Ref, process, _Pid,  _Reason} ->
            ParentPid ! {self(), missing, Philosopher}
       end.

%requests each neighbor to join the network, one at a time,
%when joining there shouldn't be any other requests for forks or leaving going on
%If another process requests to join during the joining phase, hold onto it until
%successfully joined and then handle it using the erlang mailbox.
requestJoin([], ForksList)-> ForksList;
requestJoin(Neighbors, ForksList)->
        print("Process ~p at node ~p sending request to ~s~n", 
            [self(), node(), hd(Neighbors)]),
        {philosopher, hd(Neighbors)} ! {node(), requestJoin},
        receive
            {Node, ok} -> 
                print("!Got reply (from ~p): ok!~n", [Node]),
                ForkList = dict:append(Node, {0, "SPAGHETTI SAUCE"}, ForksList),
                requestJoin(tl(Neighbors), ForkList)
        end.

%% im pretty sure that the message passing should be the other way around since 
%%we are only writing the philosophers' code and not the external controller's. 
%%Was the infinite_loop intended to be a test controller? Also, should we keep using NewRef or just use NewRef for eating?
requestForks([],_) -> print("No more neighbors to request ~n");
requestForks(Neighbors, ForksList)->
        %See if we have the fork from this edge
        case (dict:find(hd(Neighbors), ForksList)) of
            %Request the fork if 0
            {ok,[{0,_}]} -> print("Requesting fork~n"),
                          {philosopher, hd(Neighbors)} ! {node(), requestFork};
            {ok,[{1,_}]} -> ok
        end,
        requestForks(tl(Neighbors), ForksList).

% This is the joining state, initially the process will try to join
% by getting acknowledgement from all its neighors. Only when it has
% acknowledgement can it transition to thinking
philosophize(joining, Neighbors, ForkList)->
  print("Joining~n"),
  %philosophize(Ref, thinking, Neighbors);
    ForksList = requestJoin(Neighbors, ForkList),
    print("Requested to join everybody~n"),
    %% spawn processes to monitor neighbors once joined
    check_neighbors(Neighbors, self()), 
    %now we start thinking
    philosophize(thinking, Neighbors, ForksList);


%When thinking, we can be told to leave, to become hungry,
%or get request for a fork
philosophize(thinking, Neighbors, ForksList)->
  print("Thinking~n"),
  receive
      % Told by exteranl controller to leave
     {NewNode, leaving} -> 
            print("~p left, removing him from lists", [NewNode]),
            NewNeighbors = lists:delete(NewNode, Neighbors),
            NewForkList = dict:erase(NewNode, ForksList),
            philosophize(thinking, NewNeighbors, NewForkList);
      % Told by another philosopher that he's leaving
     {Pid, NewRef, leave} ->
           print("Leaving~n"),
           philosophize(leaving, Neighbors, ForksList, Pid, NewRef);
     
     % Told to become hungry
     {Pid, NewRef, become_hungry} ->
           print("becoming hungry~n"),
           %Send fork requests to everyone
           requestForks(Neighbors, ForksList),
           print("Sent requests for forks~n"),
           case (haveAllForks(Neighbors, ForksList)) of
              true -> Pid ! {NewRef, eating},
                    print("Have all forks!~n"),
                    philosophize(eating, Neighbors, ForksList, []);
              false -> print("Don't have all forks :(~n"),
                    philosophize(hungry, Neighbors, ForksList, [], Pid, NewRef)
           end;
     
     % Another process requests to join
    {NewNode, requestJoin} ->
           print("~p requested to Join, accepting~n",[NewNode]),
           NewNeighbors = lists:append(Neighbors, [NewNode]),
           ForkList = dict:append(NewNode, {1, "DIRTY"}, ForksList),
           {philosopher, NewNode} ! {node(), ok},
           philosophize(thinking, NewNeighbors, ForkList);
    % Another philosopher is checking if this philosopher is still running
    {_Pid, missing, Who} ->
           print("~p has gone missing!~n",[Who]),
           NewNeighbors = Neighbors -- [Who],
	   ForkList = dict:erase(Who, ForksList),
	   philosophize(thinking, NewNeighbors, ForkList);
    % monitor alerting that a leaving philosopher has left
    {_Pid, check, Who} ->
	   print("~p has left for sure, more SPAGHETTI for me!~n", [Who]),
	   NewNeighbors = Neighbors -- [Who],
	   ForkList = dict:erase(Who, ForksList),
	   philosophize(thinking, NewNeighbors, ForkList);
     % We get a request for a fork, which we send since we don't need it       
       {NewNode, requestFork} ->
           print("sending fork to ~p~n",[NewNode]),
           %delete the fork from the list send message
           ForkList = dict:erase(NewNode, ForksList),
           NewForkList = dict:append(NewNode, {0, "DIRTY"}, ForkList),
           {philosopher, NewNode} ! {node(), fork},
           philosophize(thinking, Neighbors, NewForkList)
  end.


% Eating phase, the philosopher has all the forks it needs from its neighbors,
% eventually exits back to thinking or leaving, requests are handled once told
% to stop eating
philosophize(eating, Neighbors, ForksList, Requests) ->
    print("eating!~n"),
    receive
      % Told by exteranl controller to leave
        {NewNode, leaving} -> 
            print("~p left, removing him from lists~n", [NewNode]),
            NewNeighbors = lists:delete(NewNode, Neighbors),
            NewForkList = dict:erase(NewNode, ForksList),
            philosophize(eating, NewNeighbors, NewForkList, Requests);
       % Told by another philosopher that he's leaving
       {Pid, NewRef, leave} ->
           print("leaving~n"),
           philosophize(leaving,Neighbors, ForksList, Pid, NewRef);
        % Told by external controller to stop eating
       {Pid, NewRef, stop_eating} ->
           print("stopped_eating~n"),
           %send the forks to the processes that wanted them
           ForkList = sendForks(Requests, ForksList),
           Pid ! {NewRef, fork},
           philosophize(thinking, Neighbors, ForkList);
      % Another philosopher is checking if this philosopher is still running
    {_Pid, missing, Who} ->
           print("~p has gone missing!~n",[Who]),
           NewNeighbors = Neighbors -- [Who],
	   ForkList = dict:erase(Who, ForksList),
	   philosophize(thinking, NewNeighbors, ForkList);
    % monitor alerting that a leaving philosopher has left
    {_Pid, check, Who} ->
	   print("~p has left for sure, more SPAGHETTI for me!~n", [Who]),
	   NewNeighbors = Neighbors -- [Who],
	   ForkList = dict:erase(Who, ForksList),
	   philosophize(thinking, NewNeighbors, ForkList);
    %Another process requests to join 
       % Handle when another process wants to join us
       {NewNode, requestJoin} ->
            print("~p requested to join~n",[NewNode]),
            %if we get a join request, just create the fork and give acknowledgement
            NewRequests = lists:append(Neighbors, [NewNode]),
            ForkList = dict:append(NewNode, {1, "DIRTY"}, ForksList),
            {philosopher, NewNode} ! {node(), ok},
            philosophize(eating, Neighbors, ForkList, NewRequests)
    end.
% Is hungry, already requested all the forks 
philosophize(hungry, Neighbors, ForksList, RequestList, Pid, Ref)->   
    print("Hungry, waiting for forks~n"),
    receive
    %Get the fork from the other process
        {NewPid, NewRef, leave} ->
           print("Leaving~n"),
           philosophize(leaving, Neighbors, ForksList, NewPid, NewRef);
        {NewNode, leaving} -> 
            print("~p left, removing him from lists~n", [NewNode]),
            NewNeighbors = lists:delete(NewNode, Neighbors),
            NewForkList = dict:erase(NewNode, ForksList),
            case (haveAllForks(NewNeighbors, NewForkList)) of
              true -> Pid ! {Ref, eating},
                    philosophize(eating, NewNeighbors, NewForkList, RequestList);
              false -> philosophize(hungry, NewNeighbors, NewForkList, RequestList, Pid, Ref)
            end;
        % Get a fork from a process, add it to the list and see if we have
        % all of them to eat
        {NewNode, fork} -> 
            print("Got fork from ~p~n",[NewNode]),
            ForkList = dict:erase(NewNode, ForksList),
            NewForkList = dict:append(NewNode, {1, "CLEAN"}, ForkList),
            case (haveAllForks(Neighbors, NewForkList)) of
              true -> Pid ! {Ref, eating},
                    philosophize(eating, Neighbors, NewForkList, RequestList);
              false -> philosophize(hungry, Neighbors, NewForkList, RequestList, Pid, Ref)
            end;
        % Another process joins, create the fork and give acknowledgement
        {NewNode, requestJoin} ->
            print("~p requested to join~n",[NewNode]),
            %if we get a join request, just create the fork and give acknowledgement
            dict:append(NewNode, [1, "DIRTY"], ForksList),
            {philosopher, NewNode} ! {node(), ok};
            % if someone requests a fork
         % Another philosopher is checking if this philosopher is still running
    	{Pid, missing, Who} ->
           print("~p has gone missing!~n",[Who]),
           NewNeighbors = Neighbors -- [Who],
	   ForkList = dict:erase(Who, ForksList),
	   philosophize(thinking, NewNeighbors, ForkList);
    % monitor alerting that a leaving philosopher has left
    	{Pid, check, Who} ->
	   print("~p has left for sure, more SPAGHETTI for me!~n", [Who]),
	   NewNeighbors = Neighbors -- [Who],
	   ForkList = dict:erase(Who, ForksList),
	   philosophize(thinking, NewNeighbors, ForkList);
 %% Check the priority and give the fork only if they have
        % higher priority
        {NewNode, requestFork} -> 
            print("~p requested the fork~n",[NewNode]),
            case (dict:find(NewNode, ForksList)) of
            %Check status
            {ok, [{1, "CLEAN"}]} -> print("My fork!, but I'll remember you wanted it~n"),
                                RequestsList = lists:append(RequestList, [NewNode]),
                                philosophize(hungry, Neighbors, ForksList, RequestsList, Pid, Ref);
            {ok, [{1, "DIRTY"}]} -> print("~p Fine, I give it up~n",[NewNode]),
                          ForkList = dict:erase(NewNode, ForksList),
                          NewForkList = dict:append(NewNode, [0, "SPAGHETTI SAUCE"], ForkList),
                          {philosopher, NewNode} ! {node(), fork},
                          philosophize(hungry, Neighbors, NewForkList, RequestList, Pid, Ref)
            end
      end,
    philosophize(hungry, Neighbors, ForksList, RequestList, Pid, Ref).


% Before leaving, the philosopher sends messages to all its neighbors
% telling them he's leaving and then leaves. Gone is not really a state,
% just alerts controller that he successfully left
philosophize(leaving, [], _, Pid, Ref) -> Pid ! {Ref, gone},
    print("I'm gone forever!~n"),
    halt();
philosophize(leaving, Neighbors, ForksList, Pid, Ref) -> 
    {philosopher, hd(Neighbors)} ! {node(), leaving},
    philosophize(leaving, tl(Neighbors), ForksList, Pid, Ref).


% Helper functions for timestamp handling.
get_two_digit_list(Number) ->
  if Number < 10 ->
       ["0"] ++ integer_to_list(Number);
     true ->
       integer_to_list(Number)
  end.

get_three_digit_list(Number) ->
  if Number < 10 ->
       ["00"] ++ integer_to_list(Number);
     Number < 100 ->
         ["0"] ++ integer_to_list(Number);
     true ->
       integer_to_list(Number)
  end.

get_formatted_time() ->
  {MegaSecs, Secs, MicroSecs} = now(),
  {{Year, Month, Date},{Hour, Minute, Second}} =
    calendar:now_to_local_time({MegaSecs, Secs, MicroSecs}),
  integer_to_list(Year) ++ ["-"] ++
  get_two_digit_list(Month) ++ ["-"] ++
  get_two_digit_list(Date) ++ [" "] ++
  get_two_digit_list(Hour) ++ [":"] ++
  get_two_digit_list(Minute) ++ [":"] ++
  get_two_digit_list(Second) ++ ["."] ++
  get_three_digit_list(MicroSecs div 1000).

% print/1
% includes system time.
print(To_Print) ->
  io:format(get_formatted_time() ++ ": " ++ To_Print).

% print/2
print(To_Print, Options) ->
  io:format(get_formatted_time() ++ ": " ++ To_Print, Options).

\end{lstlisting}


\end{document}