\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, enumerate, mathpazo, mathrsfs, fancyhdr, mathrsfs, graphicx, framed}
\usepackage[tmargin = 1in, lmargin = 1.1in, rmargin = 1in, bmargin = 1in]{geometry}
%%%%%%%%%%%%%%%%%%%%%%% IMPORTANT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                             %
%       In the end, we should submit only algorithms.pdf      %
%                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{courier}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=erlang,            % choose the language of the code
basicstyle=\footnotesize,   % the size of the fonts that are used for the code
numbers=left,               % where to put the line-numbers
numberstyle=\footnotesize,  % the size of the fonts that are used for the line-numbers
stepnumber=1,               % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,              % how far the line-numbers are from the code
backgroundcolor=\color{white}, % choose the background color. You must add \usepackage{color}
showspaces=false,           % show spaces adding particular underscores
showstringspaces=false,     % underline spaces within strings
showtabs=false,             % show tabs within strings adding particular underscores
frame=single,               % adds a frame around the code
tabsize=2,                  % sets default tabsize to 2 spaces
captionpos=b,               % sets the caption-position to bottom
breaklines=true,            % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)} % if you want to add a comment within your code
}

%%% MACROS
\newcommand{\pic}[2]{\begin{center}\includegraphics[scale=#1]{#2}\end{center}}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\comp}[1]{\overline{#1}}

%%% MATH OPERATORS
\DeclareMathOperator{\var}{Var}

%%% PARAMETERS
\setlength{\headheight}{15.2pt}
\renewcommand{\tabcolsep}{1cm}

%%% ENUMERATE
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\labelenumi}{(\theenumi)}
\renewcommand{\theenumii}{\roman{enumii}}
\renewcommand{\labelenumii}{\theenumii.}

%%% PROBLEM ENVIRONMENT
\newenvironment{problem}[1]{
\medskip \hrule \medskip
\noindent {\bf Problem #1.}
}{
\medskip \hrule \medskip
}

%%% SOLUTION ENVIRONMENT
\newenvironment{solution}{\noindent{\bf Solution.} }{

\hfill$\square$}

\begin{document}
\pagestyle{fancy}

\lhead{Tum C., Patrick L., Cory P.
}
\chead{\bf{Math 182E}}
\rhead{March 13, 2014}

\begin{center} \Large Algorithms: Dynamic Dining Philosophers \end{center}


\begin{problem}{1}
	Something something. In case we want a table, here it is.
	\begin{center}
		\begin{tabular}{ccccc}
			\hline \\[-1em]
			26.8 & 26.3 & 28.03 & 28.5 & 26.3 \\
			31.9 & 28.5 & 27.2 & 20.9 & 27.5 \\
			28.0 & 18.6 & 22.3 & 25.0 & 31.5 \\\hline
		\end{tabular}
	\end{center}
	\begin{enumerate}
		\item Progress
		\item Safety
	\end{enumerate}
\end{problem}

\begin{solution}

\item Here is the code
\begin{lstlisting}
infinite_loop(Ref, Nodel, Neighbors) ->
    spelling, Node} ! {self(), Ref, become_hungry},
    % {spelling, Node} ! {self(), Ref, stop_eating},
    % {spelling, Node} ! {self(), Ref, leave},
    receive
        %{Ref, eating} ->          
        %print("~p is eating.~n", [Ref]);
        {Ref, gone} ->
        print("~p is gone.~n", [Ref]);
        Reply ->
        print("Got unexpected message: ~p~n", [Reply])
        after ?TIMEOUT -> print("Timed out waiting for reply!")
    end,
    infinite_loop(Ref, Nodel, Neighbors)
end.
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, joining, Node, ForksNeighborsList)->
        print("joining"),
        %philosophize(Ref, thinking, Node, Neighbors);
    requestJoin(Ref, Node, ForksNeighborsList),
    philosophize(Ref, thinking, ForksNeighborsList).
    
%requests each neighbor to join the network, one at a time,
%when joining there shouldn't be any other requests for forks or leaving going on
requestJoin(_,_,[])-> ok;
requestJoin(Ref, Node, ForksNeighborsList)->
    try
        io:format("Process ~p at node ~p sending request to ~n~s",
            [self(), Node, hd(Neighbors)]),
        io:format("After~n"),
        {list_to_atom(hd(Neighbors)), Node} ! {self(), Ref, requestJoin},
        receive
            {Ref, ok} ->
                io:format("Got reply (from ~p): ok!",
                          [Ref);
            Reply ->
                io:format("Got unexpected message: ~p~n", [Reply])
        after ?TIMEOUT -> io:format("Timed out waiting for reply!")
        end,
        requestJoin(Ref, Node, tl(Neighbors))
    catch
        _:_ -> io:format("Error getting joining permission.~n")
    end.
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, thinking, Node, ForksNeighborsList)->
        receive
           {self(), NewRef, leave} ->
           print("leaving"),
           philosophize(NewRef, leaving, ForksNeighborsList);
           {self(), NewRef, become_hungry} ->
                   print("becoming hungry"),
                   philosophize(NewRef, hungry, ForksNeighborsList)
	after ?TIMEOUT -> print("Timed out waiting for reply!")
        end;
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, hungry, Node, ForksNeighborsList)->
        receive
            {self(), NewRef, leave} ->
                    print("leaving"),
                    philosophize(NewRef, leaving, Node, ForksNeighborsList);
        %   {self(), NewRef, Fork} ->  AND/OR CHECK IF ALL NEIGHBORS ARE NOT EATING?
                %print("got fork"),
                % check if has all forks
                % continue with philosophize(NewRef, 

        %end;

        % want to receive all forks and then start eating
        {controller, Node} ! {NewRef, eating},
        print("eating"),
        philosophize(Ref, eating, Node, ForksNeighborsList)
        end;
\end{lstlisting}
\begin{lstlisting}
philosophize(Ref, eating, Node, ForksNeighborsList)->
        receive
           {self(), NewRef, stop_eating} ->
                % handle forks and hygenity if doing that
                print("stopping eating"),
                philosophize(NewRef, thinking, Node, ForksNeighborsList);
           {self(), NewRef, leave} ->
                print("stopping eating and leaving"),
                %get rid of forks
                philosophize(NewRef, leaving, Node, ForksNeighborsList)
        after ?TIMEOUT -> print("Timed out waiting for reply!")
        end;
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, leaving, Node, ForksNeighborsList)->
        %need to gather forks and then leave with them
        {controller, Node} ! {Ref, gone}.
\end{lstlisting}
\begin{enumerate}
\underline{\large{Progress.}}
\end{enumerate}

\begin{enumerate}
\underline{\large{Safety.}}

In order to show that the algorithm satisfies the Safety requirement, we must show that the relevant stages satisfy the properties 
\end{enumerate}
\end{solution}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


\end{document}