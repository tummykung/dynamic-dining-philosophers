\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, enumerate, mathpazo, mathrsfs, fancyhdr, mathrsfs, graphicx, framed, float}
\usepackage[tmargin = 1in, lmargin = 1.1in, rmargin = 1in, bmargin = 1in]{geometry}
%%%%%%%%%%%%%%%%%%%%%%% IMPORTANT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                             %
%       In the end, we should submit only algorithms.pdf      %
%                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{courier}
\usepackage{color}
\usepackage{listings}
\lstset{ %
language=erlang,            % choose the language of the code
basicstyle=\footnotesize,   % the size of the fonts that are used for the code
numbers=left,               % where to put the line-numbers
numberstyle=\footnotesize,  % the size of the fonts that are used for the line-numbers
stepnumber=1,               % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=5pt,              % how far the line-numbers are from the code
backgroundcolor=\color{white}, % choose the background color. You must add \usepackage{color}
showspaces=false,           % show spaces adding particular underscores
showstringspaces=false,     % underline spaces within strings
showtabs=false,             % show tabs within strings adding particular underscores
frame=single,               % adds a frame around the code
tabsize=2,                  % sets default tabsize to 2 spaces
captionpos=b,               % sets the caption-position to bottom
breaklines=true,            % sets automatic line breaking
breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)} % if you want to add a comment within your code
}

%%% MACROS
\newcommand{\pic}[2]{\begin{center}\includegraphics[scale=#1]{#2}\end{center}}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\comp}[1]{\overline{#1}}

%%% MATH OPERATORS
\DeclareMathOperator{\var}{Var}

%%% PARAMETERS
\setlength{\headheight}{15.2pt}
\renewcommand{\tabcolsep}{1cm}

%%% ENUMERATE
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\labelenumi}{(\theenumi)}
\renewcommand{\theenumii}{\roman{enumii}}
\renewcommand{\labelenumii}{\theenumii.}

%%% PROBLEM ENVIRONMENT
\newenvironment{problem}[1]{
\medskip \hrule \medskip
\noindent {\bf Problem #1.}
}{
\medskip \hrule \medskip
}

%%% SOLUTION ENVIRONMENT
\newenvironment{solution}{\noindent{\bf Solution.} }{

\hfill$\square$}

\begin{document}
\pagestyle{fancy}

\lhead{Tum C., Patrick L., Cory P.
}
\chead{\bf{CSCI 182E} Distributed Systems}
\rhead{March 13, 2014}

\vspace*{0.1in}
\begin{center} \Large The Algorithm for the Dynamic Dining Philosophers Problem \end{center}

\section{The Dynamic Dining Philosophers}
\begin{problem}{Statement}
We need to develop and implement a protocol that allows nodes to join or leave a running dining philosophers network at runtime in an orderly fashion while maintaining an acyclic priority graph, ensuring safety, and preventing deadlock.
\end{problem}

Our solution is based on a hiegenic solution discussed in class. To avoid deadlocks, we maintain a priority graphs, in which the person with a higher priority gets to eat first when two of adjacent philosophers are hungry. We use a fork mechanism to represent the priority graph in a distributed fashion. There is exactly one fork per each edge between two nodes, where nodes represent philosophers. Each fork can be either \texttt{dirty} or \texttt{clean}. A \texttt{clean} fork implies that the person holding it has a higher priority than the person at the other end of an edge. Conversely, a \texttt{dirty} fork implies that the person holding it has a lower priority. In this assignment, we extend this algorithm to allow philosphers to join and leave the table, while still maintain the acyclic priority graph, ensuring safey, and preventing deadlock.


\section{The Algorithm}
\subsection{A set of states}
There are 6 states:
\begin{enumerate}
\item \textit{joining}
\item \textit{thinking}
\item \textit{hungry}
\item \textit{eating}
\item \textit{leaving}
\item \textit{gone}
\end{enumerate}


\subsection{Information Stored by Each Process}
In the Erlang syntax, the $\texttt{philosophize}$ function's header represents
the information stored by each process:
\begin{lstlisting}
philosophize(<state>, Node, Neighbors, ForksList)
\end{lstlisting}
In other words, a process $p$ contains the following information:
\begin{enumerate}
\item $p.state$ ($\langle\texttt{state}\rangle$): one of the six states outlined above.
\item $p.node$ its process node ($\texttt{Node}$), represented as a lowercase ASCII string with a machine name, separated by an @ symbol. (For example, \texttt{p1@ash}).
\item $p.neighbors$ ($\texttt{Neighbors}$): a list of its neighboring processes $[n_1, n_2, \ldots, n_k]$.
\item $p.fork\_states$ ($\texttt{ForkList}$): a list $[f_{p, n_1}, f_{p, n_2}, f_{p, n_3}, \ldots, f_{p, n_k}]$ of fork states for each its neighbors, in the same order as the neighboring list. The fork state can be either 0 or 1, where 1 means the fork belongs to $p$, where as 0 means the fork belongs to its corresponding neigbor. For example, if $p.neighbors = [n_1, n_2, n_3]$ and $p.fork\_states = [0, 1, 0],$ then the fork $f_{p, n_1}$ belongs to $p$; $f_{p, n_2}$ belongs to $n_2$;
and $f_{p, n_3}$ belongs to $n_3$.
\end{enumerate}

\subsection{Message Types in the System}
We categorize messages by its sender and its receiver:
\subsubsection{From Philosophers to Philosophers}
\begin{enumerate}
\item a fork $f_{i,j}$: exactly one fork per one pair of neighboring processes $i$ and $j$. A fork can be dirty (the process holding it has lower prioirty) or clean (the process holding it has higher prioirty).
\item a fork request. The sender philosopher should only send this when it is in the $hungry$ state and it does not hold a fork.
\item a joining request. The sender philosopher, who should be in the joining state, once assigned by the external controller who to join, sends a joining request to each of its intended neighbors.
\item a joining message acknowledgement.
\item a leaving notification.
\item a leaving message acknowledgement.
\end{enumerate}

\subsubsection{From External Controllers to Philosophers}
\begin{enumerate}
\item a \texttt{become\_hungry} message. The philosopher should only receive this message while \textit{thinking}; when it does, it transitions to \textit{hungry}.
\item a \texttt{stop\_eating} message. The philosopher should only receive this message while \textit{eating}; when it does, it transitions to \textit{thinking}.
\item a \texttt{leave} message. The philosopher can receive this message in any state other than \textit{joining}; when it does, it should [TODO:Fill in the description of the protocol], then immediately leave the network.
\end{enumerate}

\subsubsection{From Philosophers to External Controllers}
\begin{enumerate}
\item an \texttt{eating} message. The philosopher should send this message, when it becomes \textit{eating}, to the controller that trigger its transition to \textit{hungry} (through the \texttt{become\_hungry} message).
\item a \textit{gone} message. When it become \textit{gone}, the philosopher should send this message to the controller that sent it the \texttt{leave} message that triggerred its departure.
\end{enumerate}

\subsection{Initial Distributions of Forks}
\begin{enumerate}
\item All forks are dirty.
\item Initially, all forks are distributed to philosophers in an arbitrary way such that the corresponding graph is acyclic. We choose to use ids to decide which process has a fork initially; the process with a higher process id has a fork.
\end{enumerate}

\subsection{Actions before Transitions}
\begin{figure}[H]
\pic{0.6}{diagram}
\label{fig:diagram}
\caption{A diagram showing possible state transitions.}
\end{figure}

We will describe what would happen when a philosopher receives a fork.
TODO: Add more details

\begin{description}
\item[(1) $p.joining$ $\to$ $p.thinking$:] sends a joining request to all of its neighbors. Once it receives all joining message acknowledgments from all its neighbors, transition to the \textit{thinking} state.

\item[(2) $p.thinking$ $\to$ $p.hungry$:]
The philosopher checks to see if it holds all forks. If so, performs the transition. If not, sends requests to all forks it does not have.

\item[(3) $p.hungry$ $\to$ $p.eating$:] 
When transitioning from $p.hungry$ to $p.eating$, the philosopher makes all forks dirty, thereby making its priority lowest among all its neighbors.

% When $hungry$, a philosopher $p$ must be passed the forks once all neighbor philosophers are not eating

\item[(4) $p.eating$ $\to$ $p.thinking$:]
The phisolopher sends any forks for which it received requests while eating.

\item[(5) $(p.thinking \vee p.hungry \vee p.eating)$ $\to$ $p.leaving$:]
The philosopher sends leaving notifications to all of its neighbors.
Once received leaving notification acknowledgements from all of its neighbors,
it can immediately go to the $leaving$ state.

\item[(6) $p.leaving$ $\to$ $p.gone$:]
Eventually
\end{description}
\subsection{Incoming Request Messages}
When a fork message is received, the philosopher marks the fork as clean.

\begin{description}
\item[During $p.hungry$] if the philosopher now holds all its forks, it transitions to $eating$ state.
\end{description}
\subsection{Incoming Fork Messages}
TODO: Add more details


\subsection{How a new philosopher informs its neighbors that it has joined the network}
TODO: Add more details

Sends joining requests to all of their neighbors

\subsection{How a new philosopher knows that its neighbors are aware that it has joined the network}
TODO: Add more details

Waits for joining request acknowledgement messages from all of its neighbors.
\subsection{How a philosopher informs its neighbors that it is leaving the network}
TODO: Add more details

Sends leaving notifications to all of their neighbors

\subsection{How a philosopher knows that its neighbors are aware that it is leaving the network}
TODO: Add more details

Waits for leaving notification acknowledgements from all of its neighbors.

\section{Allowed Assumptions}

\subsection{External Controllers}
\begin{enumerate}[E1]
\item If a philosopher $p$ informs an external controller that it is \emph{eating}, the external controller will direct $p$ to become either \emph{thinking} or \emph{leaving} within a bounded time.

\item External controllers will not send duplicate or invalid control signals.

\item \label{Assump:E_guarantees_nodes_entering_network} If a process $p_1$ receives a joining request from another process $p_2$, external controllers will not send signals to ask $p_1$ to leave until $p_2$ successfully joins the network.
\end{enumerate}

\subsection{Misc.}
\begin{enumerate}[E1]
\setcounter{enumi}{3}
\item \label{Assump:message_never_lost} Messages are never lost; sufficient time is allowed for a philosopher to bootstrap itself before other philosophers send it messages.
\end{enumerate}


\section{Proof of Correctness}


\subsection{Proof of Acyclic Priority Graph Invariance}
The prioirity graph changes only in three possible cases. \ref{Assump:message_never_lost}
\begin{description}
\item[Case 1: A new process joins the network.] In this case, the new process has the lowest priority. Thus, all its neighbors will have arrow point to it. Thus, if there were a cycle, such cycle could not possibly pass this new process. Since the original graph was acyclic, there could not be cycles elsewhere as well. Thus, the resulting priority graph is still acyclic.
\item[Case 2: A process leaves the network.] A new priority graph is a subgraph of the original graph, and so the new graph cannot have cycles. If it were to have any cycles, these cycles would have presented in the original graph as well, which is not the case. Thus, the resulting priority network is acyclic.
\item[Case 3: A process eats.] In this case, based on our hiegenic algorithm, such process will then have the lowest priority among all its neighbors. Thus, all the arrow points to it. If there were a cycle, such cycle could not possibly pass this process. Since the original graph was acyclic, there could not be cycles elsewhere as well. Thus, the resulting priority graph is still acyclic.
\end{description}

\subsection{Proof of Safety Properties}

\begin{enumerate}[S1]
\item {\bfseries initially} {\it p.joining}

$p$ is given the state of $joining$ in which the philosopher $p$ is requesting to join the group and cannot possibly gain any other state until granted acceptance.

\item {\it p.joining} {\bfseries next} {\it (p.joining $\vee$ p.thinking)}

This requirement is satisfied because $p$ can be constantly trying to join the party but may be waiting infinitely or he/she can be granted the state of thinking (which is the only initial state in the party).

\item {\it p.thinking} {\bfseries next} {\it (p.thinking $\vee$ p.hungry $\vee$ p.leaving)}

When thinking, the philosopher $p$ can continue thinking, the external controller can issue the order to become hungry, or the controller may tell the philosopher to leave. No other "state" transitions are available to the philosopher at the $thinking$ state. 

\item {\it p.hungry} {\bfseries next} {\it (p.hungry $\vee$ p.eating $\vee$ p.leaving)}

If a philosopher $p$ is told by the external controller to become hungry, then it may be told to leave, it may become eating due to its hungry nature, or $p$ may remain hungry (which would likely imply a failure in the system).

\item {\it p.eating} {\bfseries next} {\it (p.eating $\vee$ p.thinking $\vee$ p.leaving)}


\item {\it p.leaving} {\bfseries next} {\it (p.leaving $\vee$ p.gone)}



\item {\it p.gone} {\bfseries next} {\it (p.gone)}



\item {\it p.eating} $\Rightarrow \langle \forall q | q \in p.neighbors \rhd \neg q.eating \rangle$
(when a philosopher $p$ is $eating$, none of its neighbors is $eating$)



\item {\it (p.thinking $\vee$ p.hungry $\vee$ p.eating)} $\Rightarrow \langle \forall q | q \in p.neighbors \rhd p \in q.neighbors \rangle$
(when a philosopher $p$ is $thinking$, $hungry$, or $eating$, each of $p$'s neighbors knows that $p$ is one of its neighbors)


\item {\it p.gone} $\Rightarrow \langle \forall q  \rhd \not\in q.neighbors \rangle$
(when a philosopher $p$ is $gone$, it is not in any other philosopher?s set of neighbors)

\end{enumerate}



\section{Proof of Progress Properties}
\begin{enumerate}[PG1]
\item
$p.joining$ $\leadsto^*$ $p.thinking$ ($^*$ if its neighbors remain in the network long enough) 

\indent After philosopher $p$ has started up, it has given itself the $joining$ state. Assuming that the neighbors in which $p$ knows about are running correctly and the network runs as expected and Assumption E\ref{Assump:E_guarantees_nodes_entering_network}, all other philosophers are bound to hear $p$'s request to join eventually and thus $p$ is guaranteed to be given the state $thinking$.

\item  $p.hungry$ $\leadsto$ $p.eating$

\indent When $hungry$, a philosopher $p$ must be passed the forks once all neighbor philosophers are not eating. TODO [Articulate this...but this is the idea]: Based on the acyclic graph property and our algorithm to make just-finished-eating processes have the lowest priority among their neighbors, we guarantee that the a hungry philosopher will eventually eat.

\item 
$p.leaving$ $\leadsto$ $p.gone$
\end{enumerate}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\section{Appendix: Relevant Code}
NOTE: This is outdated.
\begin{lstlisting}
infinite_loop(Ref, Nodel, Neighbors) ->
    philosophize, Node} ! {self(), Ref, become_hungry},
    % {spelling, Node} ! {self(), Ref, stop_eating},
    % {spelling, Node} ! {self(), Ref, leave},
    receive
        %{Ref, eating} ->          
        %print("~p is eating.~n", [Ref]);
        {Ref, gone} ->
        print("~p is gone.~n", [Ref]);
        Reply ->
        print("Got unexpected message: ~p~n", [Reply])
        after ?TIMEOUT -> print("Timed out waiting for reply!")
    end,
    infinite_loop(Ref, Nodel, Neighbors)
end.
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, joining, Node, ForksNeighborsList)->
        print("joining"),
        %philosophize(Ref, thinking, Node, Neighbors);
    requestJoin(Ref, Node, ForksNeighborsList),
    philosophize(Ref, thinking, ForksNeighborsList).
    
%requests each neighbor to join the network, one at a time,
%when joining there shouldn't be any other requests for forks or leaving going on
requestJoin(_,_,[])-> ok;
requestJoin(Ref, Node, ForksNeighborsList)->
    try
        io:format("Process ~p at node ~p sending request to ~n~s",
            [self(), Node, hd(Neighbors)]),
        io:format("After~n"),
        {list_to_atom(hd(Neighbors)), Node} ! {self(), Ref, requestJoin},
        receive
            {Ref, ok} ->
                io:format("Got reply (from ~p): ok!",
                          [Ref);
            Reply ->
                io:format("Got unexpected message: ~p~n", [Reply])
        after ?TIMEOUT -> io:format("Timed out waiting for reply!")
        end,
        requestJoin(Ref, Node, tl(Neighbors))
    catch
        _:_ -> io:format("Error getting joining permission.~n")
    end.
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, thinking, Node, ForksNeighborsList)->
        receive
           {self(), NewRef, leave} ->
           print("leaving"),
           philosophize(NewRef, leaving, ForksNeighborsList);
           {self(), NewRef, become_hungry} ->
                   print("becoming hungry"),
                   philosophize(NewRef, hungry, ForksNeighborsList)
	after ?TIMEOUT -> print("Timed out waiting for reply!")
        end;
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, hungry, Node, ForksNeighborsList)->
        receive
            {self(), NewRef, leave} ->
                    print("leaving"),
                    philosophize(NewRef, leaving, Node, ForksNeighborsList);
        %   {self(), NewRef, Fork} ->  AND/OR CHECK IF ALL NEIGHBORS ARE NOT EATING?
                %print("got fork"),
                % check if has all forks
                % continue with philosophize(NewRef, 

        %end;

        % want to receive all forks and then start eating
        {controller, Node} ! {NewRef, eating},
        print("eating"),
        philosophize(Ref, eating, Node, ForksNeighborsList)
        end;
\end{lstlisting}
\begin{lstlisting}
philosophize(Ref, eating, Node, ForksNeighborsList)->
        receive
           {self(), NewRef, stop_eating} ->
                % handle forks and hygenity if doing that
                print("stopping eating"),
                philosophize(NewRef, thinking, Node, ForksNeighborsList);
           {self(), NewRef, leave} ->
                print("stopping eating and leaving"),
                %get rid of forks
                philosophize(NewRef, leaving, Node, ForksNeighborsList)
        after ?TIMEOUT -> print("Timed out waiting for reply!")
        end;
\end{lstlisting}

\begin{lstlisting}
philosophize(Ref, leaving, Node, ForksNeighborsList)->
        %need to gather forks and then leave with them
        {controller, Node} ! {Ref, gone}.
\end{lstlisting}


\end{document}